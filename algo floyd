 public double[,] FloydWarshall()
    {
        int n = noeuds.Count;
        double[,] dist = new double[n, n]; // Matrice de distances
        int[,] next = new int[n, n]; // Matrice pour reconstruire le chemin

        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (i == j)
                {
                    dist[i, j] = 0; // La distance d'un nœud à lui-même est 0
                }
                else
                {
                    dist[i, j] = double.MaxValue; // Initialisation à l'infini
                    next[i, j] = -1; // Aucun prédécesseur initialement
                }
            }
        }

        foreach (var lien in liens)
        {
            T n1 = lien.Noeud1.Donnees;
            T n2 = lien.Noeud2.Donnees;
            double weight = lien.Distance;

            int i = GetNodeIndex(n1);
            int j = GetNodeIndex(n2);

            dist[i, j] = weight; // Distance directe
            dist[j, i] = weight; // Distance directe dans l'autre direction (graphe non orienté)
            next[i, j] = j; // Le prédécesseur de j depuis i est j
            next[j, i] = i; // Le prédécesseur de i depuis j est i
        }

        for (int k = 0; k < n; k++)
        {
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    // Si un chemin passant par k est plus court, on met à jour la distance
                    if (dist[i, j] > dist[i, k] + dist[k, j])
                    {
                        dist[i, j] = dist[i, k] + dist[k, j];
                        next[i, j] = next[i, k]; // Le prédécesseur de j depuis i passe par k
                    }
                }
            }
        }

        return dist;
    }

    private int GetNodeIndex(T noeud)
    {
        int index = 0;
        foreach (var kvp in noeuds)
        {
            if (EqualityComparer<T>.Default.Equals(kvp.Value.Donnees, noeud))
            {
                return index;
            }
            index++;
        }
        throw new Exception("Noeud introuvable");
    }

    public List<T> ReconstructPath(int[,] next, T start, T end)
    {
        int startIndex = GetNodeIndex(start);
        int endIndex = GetNodeIndex(end);
        List<T> path = new List<T>();

        if (next[startIndex, endIndex] == -1)
        {
            Console.WriteLine("Pas de chemin disponible.");
            return path;
        }

        T current = start;
        while (!EqualityComparer<T>.Default.Equals(current, end))
        {
            path.Add(current);
            current = noeuds[GetNodeIndex(current)].Donnees;
        }

        path.Add(end); // Ajouter la destination
        return path;
    }
}
