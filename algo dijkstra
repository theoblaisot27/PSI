public List<T> Dijkstra(T source, T destination)
    {
        var distances = new Dictionary<T, double>();
        var predecessors = new Dictionary<T, T>();  
        var priorityQueue = new SortedSet<T>(Comparer<T>.Create((x, y) => distances[x].CompareTo(distances[y])));
        
        foreach (var noeud in noeuds.Keys)
        {
            distances[noeud] = double.MaxValue;
            predecessors[noeud] = default(T);
            priorityQueue.Add(noeud);
        }

        distances[source] = 0;

        while (priorityQueue.Count > 0)
        {
            T currentNode = priorityQueue.Min;
            priorityQueue.Remove(currentNode);

            if (EqualityComparer<T>.Default.Equals(currentNode, destination))
            {
                return ReconstructPath(predecessors, destination);
            }

            foreach (T voisin in listeAdjacence[currentNode])
            {
                double weight = CalculerDistance(noeuds[currentNode], noeuds[voisin]); 
                double alt = distances[currentNode] + weight;

                if (alt < distances[voisin])
                {
                    distances[voisin] = alt;
                    predecessors[voisin] = currentNode;

                    priorityQueue.Remove(voisin);
                    priorityQueue.Add(voisin);
                }
            }
        }

        return new List<T>(); 
    }

    private List<T> ReconstructPath(Dictionary<T, T> predecessors, T destination)
    {
        var path = new List<T>();
        T current = destination;

        while (!EqualityComparer<T>.Default.Equals(current, default(T)))
        {
            path.Insert(0, current);
            current = predecessors[current];
        }

        return path;
    }
