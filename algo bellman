public List<T> BellmanFord(T source, T destination)
    {
       
        var distances = new Dictionary<T, double>();
        var predecessors = new Dictionary<T, T>();
        var path = new List<T>();

        
        foreach (var noeud in noeuds.Keys)
        {
            distances[noeud] = double.MaxValue;
            predecessors[noeud] = default(T);
        }

        distances[source] = 0;

        for (int i = 1; i < noeuds.Count; i++) 
        {
            foreach (var lien in liens)
            {
                T n1 = lien.Noeud1.Donnees;
                T n2 = lien.Noeud2.Donnees;
                double weight = lien.Distance;

                if (distances[n1] + weight < distances[n2])
                {
                    distances[n2] = distances[n1] + weight;
                    predecessors[n2] = n1;
                }

                if (distances[n2] + weight < distances[n1])
                {
                    distances[n1] = distances[n2] + weight;
                    predecessors[n1] = n2;
                }
            }
        }

        foreach (var lien in liens)
        {
            T n1 = lien.Noeud1.Donnees;
            T n2 = lien.Noeud2.Donnees;
            double weight = lien.Distance;

            if (distances[n1] + weight < distances[n2])
            {
                Console.WriteLine("Le graphe contient un cycle négatif");
                return new List<T>();
            }

            if (distances[n2] + weight < distances[n1])
            {
                Console.WriteLine("Le graphe contient un cycle négatif");
                return new List<T>(); 
            }
        }

        if (distances[destination] == double.MaxValue)
        {
            Console.WriteLine("Aucun chemin trouvé vers la destination");
            return new List<T>(); 
        }

        T current = destination;
        while (!EqualityComparer<T>.Default.Equals(current, default(T)))
        {
            path.Insert(0, current);
            current = predecessors[current];
        }

        return path;
    }
}
